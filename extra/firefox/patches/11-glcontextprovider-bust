--- a/dom/plugins/ipc/PluginInstanceParent.cpp
+++ b/dom/plugins/ipc/PluginInstanceParent.cpp
@@ -34,7 +34,6 @@
 #include "Layers.h"
 #include "ImageContainer.h"
 #include "GLContext.h"
-#include "GLContextProvider.h"
 #include "mozilla/layers/TextureWrapperImage.h"
 #include "mozilla/layers/TextureClientRecycleAllocator.h"
 #include "mozilla/layers/ImageBridgeChild.h"
--- a/gfx/gl/GLContext.cpp
+++ b/gfx/gl/GLContext.cpp
@@ -24,7 +24,6 @@
 #include "gfxCrashReporterUtils.h"
 #include "gfxEnv.h"
 #include "gfxUtils.h"
-#include "GLContextProvider.h"
 #include "GLTextureImage.h"
 #include "nsPrintfCString.h"
 #include "nsThreadUtils.h"
--- a/gfx/gl/GLContextProviderCGL.mm
+++ b/gfx/gl/GLContextProviderCGL.mm
@@ -226,6 +226,15 @@
   return Some(SymbolLoader(*lib));
 }
 
+// GLContextProvider impl
+
+GLContextProvider*
+GLContextProvider::GetCGL()
+{
+    static GLContextProviderCGL sContextProvider;
+    return &sContextProvider;
+}
+
 already_AddRefed<GLContext> GLContextProviderCGL::CreateForCompositorWidget(
     CompositorWidget* aCompositorWidget, bool aWebRender, bool aForceAccelerated) {
   CreateContextFlags flags = CreateContextFlags::ALLOW_OFFLINE_RENDERER;
--- a/gfx/gl/GLContextProviderEGL.cpp
+++ b/gfx/gl/GLContextProviderEGL.cpp
@@ -249,119 +249,68 @@
   ~GLContextEGLFactory() = default;
 };
 
-already_AddRefed<GLContext> GLContextEGLFactory::CreateImpl(
-    EGLNativeWindowType aWindow, bool aWebRender, bool aUseGles,
-    int32_t aDepth) {
-  nsCString failureId;
-  const auto lib = gl::DefaultEglLibrary(&failureId);
-  if (!lib) {
-    gfxCriticalNote << "Failed[3] to load EGL library: " << failureId.get();
-    return nullptr;
+
+already_AddRefed<GLContext> GLContextEGLFactory::Create(
+    EGLNativeWindowType aWindow, bool aWebRender, int32_t aDepth) {
+  RefPtr<GLContext> glContext;
+#if !defined(MOZ_WIDGET_ANDROID)
+  glContext = CreateImpl(aWindow, aWebRender, /* aUseGles */ false, aDepth);
+#endif  // !defined(MOZ_WIDGET_ANDROID)
+
+  if (!glContext) {
+    glContext = CreateImpl(aWindow, aWebRender, /* aUseGles */ true, aDepth);
   }
-  const auto egl = lib->CreateDisplay(true, &failureId);
-  if (!egl) {
-    gfxCriticalNote << "Failed[3] to create EGL library  display: "
-                    << failureId.get();
-    return nullptr;
-  }
+  return glContext.forget();
+}
 
-  int visualID = 0;
-  if (IsX11Display()) {
-#ifdef MOZ_X11
-    GdkDisplay* gdkDisplay = gdk_display_get_default();
-    auto display = gdkDisplay ? GDK_DISPLAY_XDISPLAY(gdkDisplay) : nullptr;
-    if (display) {
-      XWindowAttributes windowAttrs;
-      if (!XGetWindowAttributes(display, (Window)aWindow, &windowAttrs)) {
-        NS_WARNING("[EGL] XGetWindowAttributes() failed");
+// GLContextProvider impl
+
+GLContextProvider*
+GLContextProvider::GetEGL()
+{
+    static GLContextProviderEGL sContextProvider;
+    return &sContextProvider;
+}
+
+already_AddRefed<GLContext>
+GLContextProviderEGL::CreateForWindow(nsIWidget *aWidget)
+{
+    if (!sEGLLibrary.EnsureInitialized()) {
+        MOZ_CRASH("Failed to load EGL library!\n");
         return nullptr;
-      }
-      visualID = XVisualIDFromVisual(windowAttrs.visual);
     }
-#endif
-  }
 
-  bool doubleBuffered = true;
+    bool doubleBuffered = true;
 
-  EGLConfig config;
-  if (aWebRender && egl->mLib->IsANGLE()) {
-    // Force enable alpha channel to make sure ANGLE use correct framebuffer
-    // formart
-    const int bpp = 32;
-    const bool withDepth = true;
-    if (!CreateConfig(*egl, &config, bpp, withDepth, aUseGles)) {
-      gfxCriticalNote << "Failed to create EGLConfig for WebRender ANGLE!";
-      return nullptr;
-    }
-  } else {
-    if (aDepth) {
-      if (!CreateConfig(*egl, &config, aDepth, aWebRender, aUseGles,
-                        visualID)) {
-        gfxCriticalNote
-            << "Failed to create EGLConfig for WebRender with depth!";
+    EGLConfig config;
+    if (!CreateConfig(&config)) {
+        MOZ_CRASH("Failed to create EGLConfig!\n");
         return nullptr;
-      }
-    } else {
-      if (!CreateConfigScreen(*egl, &config,
-                              /* aEnableDepthBuffer */ aWebRender, aUseGles,
-                              visualID)) {
-        gfxCriticalNote << "Failed to create EGLConfig!";
-        return nullptr;
-      }
     }
-  }
 
-  EGLSurface surface = EGL_NO_SURFACE;
-  if (aWindow) {
-    surface = mozilla::gl::CreateSurfaceFromNativeWindow(*egl, aWindow, config);
-    if (!surface) {
-      return nullptr;
+    EGLSurface surface = mozilla::gl::CreateSurfaceForWindow(aWidget, config);
+
+    if (surface == EGL_NO_SURFACE) {
+        MOZ_CRASH("Failed to create EGLSurface!\n");
+        return nullptr;
     }
-  }
 
-  CreateContextFlags flags = CreateContextFlags::NONE;
-  if (aWebRender && aUseGles) {
-    flags |= CreateContextFlags::PREFER_ES3;
-  }
-  if (!aWebRender) {
-    flags |= CreateContextFlags::REQUIRE_COMPAT_PROFILE;
-  }
+    SurfaceCaps caps = SurfaceCaps::Any();
+    nsRefPtr<GLContextEGL> glContext =
+        GLContextEGL::CreateGLContext(caps,
+                                      nullptr, false,
+                                      config, surface);
 
-  const auto desc = GLContextDesc{{flags}, false};
-  RefPtr<GLContextEGL> gl = GLContextEGL::CreateGLContext(
-      egl, desc, config, surface, aUseGles, &failureId);
-  if (!gl) {
-    const auto err = egl->mLib->fGetError();
-    gfxCriticalNote << "Failed to create EGLContext!: " << gfx::hexa(err);
-    mozilla::gl::DestroySurface(*egl, surface);
-    return nullptr;
-  }
+    if (!glContext) {
+        MOZ_CRASH("Failed to create EGLContext!\n");
+        DestroySurface(surface);
+        return nullptr;
+    }
 
-  gl->MakeCurrent();
-  gl->SetIsDoubleBuffered(doubleBuffered);
+    glContext->MakeCurrent();
+    glContext->SetIsDoubleBuffered(doubleBuffered);
 
-  if (surface && IsWaylandDisplay()) {
-    // Make eglSwapBuffers() non-blocking on wayland
-    egl->fSwapInterval(0);
-  }
-  if (aWebRender && egl->mLib->IsANGLE()) {
-    MOZ_ASSERT(doubleBuffered);
-    egl->fSwapInterval(0);
-  }
-  return gl.forget();
-}
-
-already_AddRefed<GLContext> GLContextEGLFactory::Create(
-    EGLNativeWindowType aWindow, bool aWebRender, int32_t aDepth) {
-  RefPtr<GLContext> glContext;
-#if !defined(MOZ_WIDGET_ANDROID)
-  glContext = CreateImpl(aWindow, aWebRender, /* aUseGles */ false, aDepth);
-#endif  // !defined(MOZ_WIDGET_ANDROID)
-
-  if (!glContext) {
-    glContext = CreateImpl(aWindow, aWebRender, /* aUseGles */ true, aDepth);
-  }
-  return glContext.forget();
+    return glContext.forget();
 }
 
 /* static */
--- a/gfx/gl/GLContextProviderImpl.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef IN_GL_CONTEXT_PROVIDER_H
-#  error GLContextProviderImpl.h must only be included from GLContextProvider.h
-#endif
-
-#ifndef GL_CONTEXT_PROVIDER_NAME
-#  error GL_CONTEXT_PROVIDER_NAME not defined
-#endif
-#if defined(MOZ_WIDGET_ANDROID)
-#  include "GLTypes.h"  // for EGLSurface and EGLConfig
-#endif                  // defined(MOZ_WIDGET_ANDROID)
-
-class GL_CONTEXT_PROVIDER_NAME {
- public:
-  /**
-   * Create a context that renders to the surface of the widget represented by
-   * the compositor widget that is passed in. The context is always created
-   * with an RGB pixel format, with no alpha, depth or stencil.
-   * If any of those features are needed, either use a framebuffer, or
-   * use CreateOffscreen.
-   *
-   * This context will attempt to share resources with all other window
-   * contexts.  As such, it's critical that resources allocated that are not
-   * needed by other contexts be deleted before the context is destroyed.
-   *
-   * The GetSharedContext() method will return non-null if sharing
-   * was successful.
-   *
-   * Note: a context created for a widget /must not/ hold a strong
-   * reference to the widget; otherwise a cycle can be created through
-   * a GL layer manager.
-   *
-   * @param aCompositorWidget Widget whose surface to create a context for
-   * @param aForceAccelerated true if only accelerated contexts are allowed
-   *
-   * @return Context to use for the window
-   */
-  static already_AddRefed<GLContext> CreateForCompositorWidget(
-      mozilla::widget::CompositorWidget* aCompositorWidget, bool aWebRender,
-      bool aForceAccelerated);
-
-  /// Just create a context. We'll add offscreen stuff ourselves.
-  static already_AddRefed<GLContext> CreateHeadless(
-      const GLContextCreateDesc&, nsACString* const out_failureId);
-
-  /**
-   * Get a pointer to the global context, creating it if it doesn't exist.
-   */
-  static GLContext* GetGlobalContext();
-
-  /**
-   * Free any resources held by this Context Provider.
-   */
-  static void Shutdown();
-};
--- a/gfx/gl/GLContextProviderNull.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-/* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "GLContextProvider.h"
-
-namespace mozilla {
-namespace gl {
-
-using namespace mozilla::widget;
-
-already_AddRefed<GLContext> GLContextProviderNull::CreateForCompositorWidget(
-    CompositorWidget* aCompositorWidget, bool aWebRender,
-    bool aForceAccelerated) {
-  return nullptr;
-}
-
-already_AddRefed<GLContext> GLContextProviderNull::CreateHeadless(
-    const GLContextCreateDesc&, nsACString* const out_failureId) {
-  *out_failureId = "FEATURE_FAILURE_NULL"_ns;
-  return nullptr;
-}
-
-GLContext* GLContextProviderNull::GetGlobalContext() { return nullptr; }
-
-void GLContextProviderNull::Shutdown() {}
-
-} /* namespace gl */
-} /* namespace mozilla */
--- a/gfx/layers/LayerScope.cpp
+++ b/gfx/layers/LayerScope.cpp
@@ -26,7 +26,6 @@
 #include "nsIWidget.h"
 
 #include "GLContext.h"
-#include "GLContextProvider.h"
 #include "GLReadTexImageHelper.h"
 
 #include <memory>
--- a/gfx/thebes/gfxPlatform.cpp
+++ b/gfx/thebes/gfxPlatform.cpp
@@ -1248,6 +1248,14 @@
   ClearOnShutdown(&ScrollMetadata::sNullMetadata);
 }
 
+static voidShutdownProvider(mozilla::gl::GLContextProvider* provider)
+{
+    if (!provider)
+        return;
+
+    provider->Shutdown();
+}
+
 void gfxPlatform::Shutdown() {
   // In some cases, gPlatform may not be created but Shutdown() called,
   // e.g., during xpcshell tests.
@@ -1292,18 +1300,11 @@
 
   gPlatform->mVsyncSource = nullptr;
 
-  // Shut down the default GL context provider.
-  GLContextProvider::Shutdown();
-
-#if defined(XP_WIN)
-  // The above shutdown calls operate on the available context providers on
-  // most platforms.  Windows is a "special snowflake", though, and has three
-  // context providers available, so we have to shut all of them down.
-  // We should only support the default GL provider on Windows; then, this
-  // could go away. Unfortunately, we currently support WGL (the default) for
-  // WebGL on Optimus.
-  GLContextProviderEGL::Shutdown();
-#endif
+  // Shut. Down. Everything!
+  ShutdownProvider(mozilla::gl::GLContextProvider::GetCGL());
+  ShutdownProvider(mozilla::gl::GLContextProvider::GetEGL());
+  ShutdownProvider(mozilla::gl::GLContextProvider::GetGLX());
+  ShutdownProvider(mozilla::gl::GLContextProvider::GetWGL());
 
   if (XRE_IsParentProcess()) {
     GPUProcessManager::Shutdown();
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -108,7 +108,6 @@
 #include "gfxImageSurface.h"
 #include "gfxUtils.h"
 #include "Layers.h"
-#include "GLContextProvider.h"
 #include "mozilla/gfx/2D.h"
 #include "mozilla/gfx/HelpersCairo.h"
 #include "mozilla/gfx/GPUProcessManager.h"
--- a/gfx/gl/moz.build
+++ b/gfx/gl/moz.build
@@ -13,7 +13,7 @@
 elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'uikit':
     gl_provider = 'EAGL'
 elif CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gtk':
-    if CONFIG['MOZ_EGL_XRENDER_COMPOSITE']:
+    if CONFIG['MOZ_EGL_XRENDER_COMPOSITE'] or CONFIG['MOZ_WAYLAND']:
         gl_provider = 'EGL'
     else:
         gl_provider = 'GLX'
@@ -33,7 +33,6 @@
     'GLContext.h',
     'GLContextEGL.h',
     'GLContextProvider.h',
-    'GLContextProviderImpl.h',
     'GLContextSymbols.h',
     'GLContextTypes.h',
     'GLDefs.h',
@@ -125,6 +124,7 @@
         'GLContextProviderWayland.cpp',
         'SharedSurfaceDMABUF.cpp'
     ]
+    OS_LIBS += ['gdk-3']
 
 UNIFIED_SOURCES += [
     'AndroidSurfaceTexture.cpp',
--- a/gfx/gl/GLContextProvider.h
+++ b/gfx/gl/GLContextProvider.h
@@ -8,7 +8,6 @@
 
 #include "mozilla/AlreadyAddRefed.h"
 
-#include "GLContextTypes.h"
 #include "SurfaceTypes.h"
 
 #include "nsSize.h"  // for gfx::IntSize (needed by GLContextProviderImpl.h below)
@@ -21,79 +20,177 @@
 }
 namespace gl {
 
-#define IN_GL_CONTEXT_PROVIDER_H
+    class GLContext;
 
-// Null is always there
-#define GL_CONTEXT_PROVIDER_NAME GLContextProviderNull
-#include "GLContextProviderImpl.h"
-#undef GL_CONTEXT_PROVIDER_NAME
+struct GLContextProvider
+{
+    static GLContextProvider* GetCGL();
+    static GLContextProvider* GetEGL();
+    static GLContextProvider* GetGLX();
+    static GLContextProvider* GetWGL();
 
-#ifdef XP_WIN
-#  define GL_CONTEXT_PROVIDER_NAME GLContextProviderWGL
-#  include "GLContextProviderImpl.h"
-#  undef GL_CONTEXT_PROVIDER_NAME
-#  define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderWGL
-#  define DEFAULT_IMPL WGL
-#endif
+    static GLContextProvider* GetDefault() {
+        GLContextProvider* factory = GetWGL();
+        if (!factory)
+            factory = GetCGL();
+        if (!factory)
+            factory = GetGLX();
+        if (!factory)
+            factory = GetEGL();
 
+        return factory;
+    }
+ 
+    typedef gfx::SurfaceCaps SurfaceCaps;
+    /**
+     * Create a context that renders to the surface of the widget that is
+     * passed in.  The context is always created with an RGB pixel format,
+     * with no alpha, depth or stencil.  If any of those features are needed,
+     * either use a framebuffer, or use CreateOffscreen.
+     *
+     * This context will attempt to share resources with all other window
+     * contexts.  As such, it's critical that resources allocated that are not
+     * needed by other contexts be deleted before the context is destroyed.
+     *
+     * The GetSharedContext() method will return non-null if sharing
+     * was successful.
+     *
+     * Note: a context created for a widget /must not/ hold a strong
+     * reference to the widget; otherwise a cycle can be created through
+     * a GL layer manager.
+     *
+     * @param aWidget Widget whose surface to create a context for
+     *
+     * @return Context to use for the window
+     */
+    virtual already_AddRefed<GLContext> CreateForWindow(nsIWidget* widget) = 0;
+
+    /**
+     * Create a context for offscreen rendering.  The target of this
+     * context should be treated as opaque -- it might be a FBO, or a
+     * pbuffer, or some other construct.  Users of this GLContext
+     * should bind framebuffer 0 directly to use this offscreen buffer.
+     *
+     * The offscreen context returned by this method will always have
+     * the ability to be rendered into a context created by a window.
+     * It might or might not share resources with the global context;
+     * query GetSharedContext() for a non-null result to check.  If
+     * resource sharing can be avoided on the target platform, it will
+     * be, in order to isolate the offscreen context.
+     *
+     * @param aSize The initial size of this offscreen context.
+     * @param aFormat The ContextFormat for this offscreen context.
+     *
+     * @return Context to use for offscreen rendering
+     */
+    virtual already_AddRefed<GLContext> CreateOffscreen(const gfxIntSize& size,
+                                                        const SurfaceCaps& caps) = 0;
+
+    /**
+     * Get a pointer to the global context, creating it if it doesn't exist.
+     */
+    virtual GLContext* GetGlobalContext() = 0;
+
+     /**
+      * Free any resources held by this Context Provider.
+      */
+     virtual void Shutdown() = 0;
+ };
+ 
+ 
+ #ifdef AUTO_DEFN_PROVIDER_GET_CGL
+ #error AUTO_DEFN_PROVIDER_GET_CGL already defined!
+ #endif
+ #define AUTO_DEFN_PROVIDER_GET_CGL \
+     GLContextProvider* \
+     GLContextProvider::GetCGL() \
+     { \
+         return nullptr; \
+     }
+ 
+ #ifdef AUTO_DEFN_PROVIDER_GET_EGL
+ #error AUTO_DEFN_PROVIDER_GET_EGL already defined!
+ #endif
+ #define AUTO_DEFN_PROVIDER_GET_EGL \
+     GLContextProvider* \
+     GLContextProvider::GetEGL() \
+     { \
+         return nullptr; \
+     }
+ 
+ #ifdef AUTO_DEFN_PROVIDER_GET_GLX
+ #error AUTO_DEFN_PROVIDER_GET_GLX already defined!
+ #endif
+ #define AUTO_DEFN_PROVIDER_GET_GLX \
+     GLContextProvider* \
+     GLContextProvider::GetGLX() \
+     { \
+         return nullptr; \
+     }
+ 
+ #ifdef AUTO_DEFN_PROVIDER_GET_WGL
+ #error AUTO_DEFN_PROVIDER_GET_WGL already defined!
+ #endif
+ #define AUTO_DEFN_PROVIDER_GET_WGL \
+     GLContextProvider* \
+     GLContextProvider::GetWGL() \
+     { \
+         return nullptr; \
+     }
+ 
+ 
+ #ifdef DECL_PROVIDER_STRUCT
+ #error DECL_PROVIDER_STRUCT already defined!
+ #endif
+ #define DECL_PROVIDER_STRUCT(Name) \
+     struct Name : GLContextProvider \
+     { \
+         virtual already_AddRefed<GLContext> CreateForWindow(nsIWidget* widget) MOZ_OVERRIDE; \
+         virtual already_AddRefed<GLContext> CreateOffscreen(const gfxIntSize& size, \
+                                                             const SurfaceCaps& caps) MOZ_OVERRIDE; \
+         virtual GLContext* GetGlobalContext() MOZ_OVERRIDE; \
+         virtual void Shutdown() MOZ_OVERRIDE; \
+     };
+ 
+
 #ifdef XP_MACOSX
-#  define GL_CONTEXT_PROVIDER_NAME GLContextProviderCGL
-#  include "GLContextProviderImpl.h"
-#  undef GL_CONTEXT_PROVIDER_NAME
-#  define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderCGL
+  DECL_PROVIDER_STRUCT(GLContextProviderCGL)
+
+  #undef AUTO_DEFN_PROVIDER_GET_CGL
+  #define AUTO_DEFN_PROVIDER_GET_CGL // No auto definition.
 #endif
 
-#define GL_CONTEXT_PROVIDER_NAME GLContextProviderEGL
-#include "GLContextProviderImpl.h"
-#undef GL_CONTEXT_PROVIDER_NAME
-
 #if defined(MOZ_X11)
-#  define GL_CONTEXT_PROVIDER_NAME GLContextProviderGLX
-#  include "GLContextProviderImpl.h"
-#  undef GL_CONTEXT_PROVIDER_NAME
-#  define GL_CONTEXT_PROVIDER_NAME GLContextProviderX11
-#  include "GLContextProviderImpl.h"
-#  undef GL_CONTEXT_PROVIDER_NAME
-#  if defined(MOZ_WAYLAND)
-#    define GL_CONTEXT_PROVIDER_NAME GLContextProviderWayland
-#    include "GLContextProviderImpl.h"
-#    undef GL_CONTEXT_PROVIDER_NAME
-#    define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderWayland
-#  endif
-#  ifndef GL_CONTEXT_PROVIDER_DEFAULT
-#    define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderX11
-#  endif
-#endif
+  DECL_PROVIDER_STRUCT(GLContextProviderGLX)
 
-#ifndef GL_CONTEXT_PROVIDER_DEFAULT
-#  define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderEGL
+  #undef AUTO_DEFN_PROVIDER_GET_GLX
+  #define AUTO_DEFN_PROVIDER_GET_GLX // No auto definition.
 #endif
 
-#if defined(MOZ_WIDGET_UIKIT)
-#  define GL_CONTEXT_PROVIDER_NAME GLContextProviderEAGL
-#  include "GLContextProviderImpl.h"
-#  undef GL_CONTEXT_PROVIDER_NAME
-#  ifndef GL_CONTEXT_PROVIDER_DEFAULT
-#    define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderEAGL
-#  endif
+#ifdef XP_WIN
+    DECL_PROVIDER_STRUCT(GLContextProviderWGL)
+
+    #undef AUTO_DEFN_PROVIDER_GET_WGL
+    #define AUTO_DEFN_PROVIDER_GET_WGL // no auto definition.
 #endif
 
-#ifdef MOZ_GL_PROVIDER
-#  define GL_CONTEXT_PROVIDER_NAME MOZ_GL_PROVIDER
-#  include "GLContextProviderImpl.h"
-#  undef GL_CONTEXT_PROVIDER_NAME
-#  define GL_CONTEXT_PROVIDER_DEFAULT MOZ_GL_PROVIDER
+#if defined(MOZ_WAYLAND)
+    DECL_PROVIDER_STRUCT(GLContextProviderEGL)
+
+    #undef AUTO_DEFN_PROVIDER_GET_EGL
+    #define AUTO_DEFN_PROVIDER_GET_EGL
 #endif
 
-#ifdef GL_CONTEXT_PROVIDER_DEFAULT
-typedef GL_CONTEXT_PROVIDER_DEFAULT GLContextProvider;
-#else
-typedef GLContextProviderNull GLContextProvider;
+#if defined(MOZ_WIDGET_UIKIT)
+    DECL_PROVIDER_STRUCT(GLContextProviderEAGL)
+
+    #undef AUTO_DEFN_PROVIDER_GET_EAGL
+    #define AUTO_DEFN_PROVIDER_GET_EAGL
 #endif
 
-#undef IN_GL_CONTEXT_PROVIDER_H
+#undef DECL_PROVIDER_STRUCT
 
 }  // namespace gl
 }  // namespace mozilla
 
-#endif
+#endif // GLCONTEXTPROVIDER_H_
