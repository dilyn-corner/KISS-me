--- a/kiss
+++ b/kiss
@@ -351,6 +351,9 @@
     if null "${2##git+*}"; then
         _res=$2
 
+    elif null "${2##fossil+*}"; then
+        _res=$2
+
     # Remote source (cached).
     elif [ -f "$src_dir/$1/${3:+"$3/"}${2##*/}" ]; then
         _res=$src_dir/$1/${3:+"$3/"}${2##*/}
@@ -449,6 +452,11 @@
     git -c advice.detachedHead=0 checkout "${com:-FETCH_HEAD}"
 }
 
+pkg_source_fossil() {
+    url=$1 com=${url##*[@#]} com=${com#${url%[#@]*}}
+    fossil open -f "${url%[#@]*}" "${2:-trunk}"
+}
+
 pkg_source_tar() {
     # This is a portable shell implementation of GNU tar's
     # '--strip-components 1'. Use of this function denotes a
@@ -516,8 +524,9 @@
         null "$_res" || mkcd "$mak_dir/$1/$dest"
 
         case $_res in
-            git+*)
-                pkg_source_git "${_res##git+}"
+            git+*|fossil+*)
+                vcs="${src%%+*}"
+                "pkg_source_$vcs" "${_res##${vcs}+}"
             ;;
 
             *.tar|*.tar.??|*.tar.???|*.tar.????|*.t?z)
@@ -1530,6 +1539,52 @@
     fi
 }
 
+repository_update_git() {
+   # Go to the repository's root directory.
+   git_root=$(git rev-parse --show-toplevel)
+   cd "${git_root:?"failed to find git root for '$PWD'"}"
+
+   # Go to the real root directory if this is a submodule.
+   git_root=$(git rev-parse --show-superproject-working-tree)
+   cd "${git_root:-"$PWD"}"
+
+   contains "$repos" "$PWD" || {
+       repos="$repos $PWD "
+
+       # arg1: pre-update
+       # env:  PWD is path to repository
+       run_hook pre-update
+
+       # Display whether or not signature verification is enabled.
+       _sig=$(git config --get --default false merge.verifySignatures)
+
+       log "$PWD" "[verify: $_sig]"
+
+       if ! am_owner "$PWD"; then
+           log "$PWD" "Need '$user' to update"
+           as_user git pull
+           as_user git submodule update --remote --init -f
+       else
+           git pull
+           git submodule update --remote --init -f
+       fi
+
+       # arg1: post-update
+       # env:  PWD is path to repository
+       run_hook post-update
+   }
+}
+
+repository_update_fossil() {
+    if ! am_owner "$PWD"; then
+        as_user fossil pull
+        as_user fossil update
+    else
+        fossil pull
+        fossil update
+    fi
+}
+
 pkg_update() {
     # Check all installed packages for updates. So long as the installed
     # version and the version in the repositories differ, it's considered
@@ -1553,45 +1608,16 @@
 
         cd "$repo"
 
-        git remote >/dev/null 2>&1 || {
-            log "$repo" " "
-            printf 'Skipping git pull, not a repository\n'
+        if git remote >/dev/null 2>&1; then
+            repository_update_git
+        elif
+            fossil info >/dev/null 2>&1; then
+            repository_update_fossil
+        else
+            printf 'Not a version controlled repository\n'
             continue
-        }
+        fi
 
-        # Go to the repository's root directory.
-        git_root=$(git rev-parse --show-toplevel)
-        cd "${git_root:?"failed to find git root for '$PWD'"}"
-
-        # Go to the real root directory if this is a submodule.
-        git_root=$(git rev-parse --show-superproject-working-tree)
-        cd "${git_root:-"$PWD"}"
-
-        contains "$repos" "$PWD" || {
-            repos="$repos $PWD "
-
-            # arg1: pre-update
-            # env:  PWD is path to repository
-            run_hook pre-update
-
-            # Display whether or not signature verification is enabled.
-            _sig=$(git config --get --default false merge.verifySignatures)
-
-            log "$PWD" "[verify: $_sig]"
-
-            if ! am_owner "$PWD"; then
-                log "$PWD" "Need '$user' to update"
-                as_user git pull
-                as_user git submodule update --remote --init -f
-            else
-                git pull
-                git submodule update --remote --init -f
-            fi
-
-            # arg1: post-update
-            # env:  PWD is path to repository
-            run_hook post-update
-        }
     done
 
     log "Checking for new package versions"
